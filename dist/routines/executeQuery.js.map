{"version":3,"sources":["../../src/routines/executeQuery.js"],"names":["TRANSACTION_ROLLBACK_ERROR_PREFIX","retryTransaction","connectionLogger","connection","transactionQueries","retryLimit","result","remainingRetries","attempt","query","transactionQuery","trace","queryId","executionContext","executionRoutine","sql","values","native","error","code","startsWith","clientConfiguration","rawSql","inheritedQueryId","slonik","terminated","BackendTerminatedError","trim","InvalidInputError","queryInputTime","process","hrtime","bigint","stackTrace","captureStackTrace","callSites","columnNumber","callSite","fileName","lineNumber","log","child","originalQuery","actualQuery","connectionId","poolId","sandbox","transactionId","interceptor","interceptors","beforeTransformQuery","transformQuery","beforeQueryExecution","info","notices","noticeListener","notice","push","on","transactionRetryLimit","message","includes","StatementTimeoutError","StatementCancelledError","NotNullIntegrityConstraintViolationError","constraint","ForeignKeyIntegrityConstraintViolationError","UniqueIntegrityConstraintViolationError","CheckIntegrityConstraintViolationError","off","queryExecutionError","UnexpectedStateError","afterQueryExecution","rows","transformRow","fields","row","beforeQueryResult"],"mappings":"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","sourcesContent":["// @flow\n\nimport {\n  map,\n} from 'inline-loops.macro';\nimport {\n  getStackTrace,\n} from 'get-stack-trace';\nimport {\n  serializeError,\n} from 'serialize-error';\nimport {\n  createQueryId,\n  normaliseQueryValues,\n} from '../utilities';\nimport {\n  BackendTerminatedError,\n  CheckIntegrityConstraintViolationError,\n  ForeignKeyIntegrityConstraintViolationError,\n  InvalidInputError,\n  NotNullIntegrityConstraintViolationError,\n  StatementCancelledError,\n  StatementTimeoutError,\n  UnexpectedStateError,\n  UniqueIntegrityConstraintViolationError,\n} from '../errors';\nimport type {\n  ClientConfigurationType,\n  InternalDatabaseConnectionType,\n  LoggerType,\n  PrimitiveValueExpressionType,\n  QueryContextType,\n  QueryIdType,\n  QueryResultRowType,\n  QueryType,\n} from '../types';\n\ntype ExecutionRoutineType = (\n  connection: InternalDatabaseConnectionType,\n  sql: string,\n  values: $ReadOnlyArray<PrimitiveValueExpressionType>,\n  queryContext: QueryContextType,\n  query: QueryType\n) => Promise<*>;\n\ntype TransactionQueryType = {|\n  +executionContext: QueryContextType,\n  +executionRoutine: ExecutionRoutineType,\n  +sql: string,\n  +values: $ReadOnlyArray<PrimitiveValueExpressionType>,\n|};\n\n// @see https://www.postgresql.org/docs/current/errcodes-appendix.html\nconst TRANSACTION_ROLLBACK_ERROR_PREFIX = '40';\n\nconst retryTransaction = async (\n  connectionLogger: LoggerType,\n  connection: InternalDatabaseConnectionType,\n  transactionQueries: $ReadOnlyArray<TransactionQueryType>,\n  retryLimit: number,\n) => {\n  let result;\n  let remainingRetries = retryLimit;\n  let attempt = 0;\n\n  // @todo Provide information about the queries being retried to the logger.\n  while (remainingRetries-- > 0) {\n    attempt++;\n\n    try {\n      // @todo Respect SAVEPOINTs.\n      await connection.query('ROLLBACK');\n      await connection.query('BEGIN');\n\n      for (const transactionQuery of transactionQueries) {\n        connectionLogger.trace({\n          attempt,\n          queryId: transactionQuery.executionContext.queryId,\n        }, 'retrying query');\n\n        result = await transactionQuery.executionRoutine(\n          connection,\n          transactionQuery.sql,\n          normaliseQueryValues(transactionQuery.values, connection.native),\n\n          // @todo Refresh execution context to reflect that the query has been re-tried.\n          // This (probably) requires changing `queryId` and `queryInputTime`.\n          // It should be needed only for the last query (because other queries will not be processed by the middlewares).\n          transactionQuery.executionContext,\n          {\n            sql: transactionQuery.sql,\n            values: transactionQuery.values,\n          },\n        );\n      }\n    } catch (error) {\n      if (typeof error.code === 'string' && error.code.startsWith(TRANSACTION_ROLLBACK_ERROR_PREFIX)) {\n        continue;\n      }\n\n      throw error;\n    }\n  }\n\n  return result;\n};\n\n// eslint-disable-next-line complexity\nexport default async (\n  connectionLogger: LoggerType,\n  connection: InternalDatabaseConnectionType,\n  clientConfiguration: ClientConfigurationType,\n  rawSql: string,\n  values: $ReadOnlyArray<PrimitiveValueExpressionType>,\n  inheritedQueryId?: QueryIdType,\n  executionRoutine: ExecutionRoutineType,\n) => {\n  if (connection.connection.slonik.terminated) {\n    throw new BackendTerminatedError(connection.connection.slonik.terminated);\n  }\n\n  if (rawSql.trim() === '') {\n    throw new InvalidInputError('Unexpected SQL input. Query cannot be empty.');\n  }\n\n  if (rawSql.trim() === '$1') {\n    throw new InvalidInputError('Unexpected SQL input. Query cannot be empty. Found only value binding.');\n  }\n\n  const queryInputTime = process.hrtime.bigint();\n\n  let stackTrace = null;\n\n  if (clientConfiguration.captureStackTrace) {\n    const callSites = await getStackTrace();\n\n    stackTrace = map(callSites, (callSite) => {\n      return {\n        columnNumber: callSite.columnNumber,\n        fileName: callSite.fileName,\n        lineNumber: callSite.lineNumber,\n      };\n    });\n  }\n\n  const queryId = inheritedQueryId || createQueryId();\n\n  const log = connectionLogger.child({\n    queryId,\n  });\n\n  const originalQuery = {\n    sql: rawSql,\n    values,\n  };\n\n  let actualQuery = {\n    ...originalQuery,\n  };\n\n  const executionContext: QueryContextType = {\n    connectionId: connection.connection.slonik.connectionId,\n    log,\n    originalQuery,\n    poolId: connection.connection.slonik.poolId,\n    queryId,\n    queryInputTime,\n    sandbox: {},\n    stackTrace,\n    transactionId: connection.connection.slonik.transactionId,\n  };\n\n  for (const interceptor of clientConfiguration.interceptors) {\n    if (interceptor.beforeTransformQuery) {\n      interceptor.beforeTransformQuery(executionContext, actualQuery);\n    }\n  }\n\n  for (const interceptor of clientConfiguration.interceptors) {\n    if (interceptor.transformQuery) {\n      actualQuery = interceptor.transformQuery(executionContext, actualQuery);\n    }\n  }\n\n  let result;\n\n  for (const interceptor of clientConfiguration.interceptors) {\n    if (interceptor.beforeQueryExecution) {\n      result = await interceptor.beforeQueryExecution(executionContext, actualQuery);\n\n      if (result) {\n        log.info('beforeQueryExecution interceptor produced a result; short-circuiting query execution using beforeQueryExecution result');\n\n        return result;\n      }\n    }\n  }\n\n  const notices = [];\n\n  const noticeListener = (notice) => {\n    notices.push(notice);\n  };\n\n  connection.on('notice', noticeListener);\n\n  try {\n    try {\n      try {\n        if (connection.connection.slonik.transactionQueries) {\n          connection.connection.slonik.transactionQueries.push({\n            executionContext,\n            executionRoutine,\n            sql: actualQuery.sql,\n            values: actualQuery.values,\n          });\n        }\n\n        result = await executionRoutine(\n          connection,\n          actualQuery.sql,\n          normaliseQueryValues(actualQuery.values, connection.native),\n          executionContext,\n          actualQuery,\n        );\n      } catch (error) {\n        if (typeof error.code === 'string' && error.code.startsWith(TRANSACTION_ROLLBACK_ERROR_PREFIX) && clientConfiguration.transactionRetryLimit > 0) {\n          result = await retryTransaction(\n            connectionLogger,\n            connection,\n            connection.connection.slonik.transactionQueries,\n            clientConfiguration.transactionRetryLimit,\n          );\n        } else {\n          throw error;\n        }\n      }\n    } catch (error) {\n      log.error({\n        error: serializeError(error),\n      }, 'execution routine produced an error');\n\n      // 'Connection terminated' refers to node-postgres error.\n      // @see https://github.com/brianc/node-postgres/blob/eb076db5d47a29c19d3212feac26cd7b6d257a95/lib/client.js#L199\n      if (error.code === '57P01' || error.message === 'Connection terminated') {\n        connection.connection.slonik.terminated = error;\n\n        throw new BackendTerminatedError(error);\n      }\n\n      if (error.code === '57014' && error.message.includes('canceling statement due to statement timeout')) {\n        throw new StatementTimeoutError(error);\n      }\n\n      if (error.code === '57014') {\n        throw new StatementCancelledError(error);\n      }\n\n      if (error.code === '23502') {\n        throw new NotNullIntegrityConstraintViolationError(error, error.constraint);\n      }\n\n      if (error.code === '23503') {\n        throw new ForeignKeyIntegrityConstraintViolationError(error, error.constraint);\n      }\n\n      if (error.code === '23505') {\n        throw new UniqueIntegrityConstraintViolationError(error, error.constraint);\n      }\n\n      if (error.code === '23514') {\n        throw new CheckIntegrityConstraintViolationError(error, error.constraint);\n      }\n\n      throw error;\n    } finally {\n      connection.off('notice', noticeListener);\n    }\n  } catch (error) {\n    for (const interceptor of clientConfiguration.interceptors) {\n      if (interceptor.queryExecutionError) {\n        await interceptor.queryExecutionError(executionContext, actualQuery, error);\n      }\n    }\n\n    throw error;\n  }\n\n  if (!result) {\n    throw new UnexpectedStateError();\n  }\n\n  // $FlowFixMe\n  result.notices = notices;\n\n  for (const interceptor of clientConfiguration.interceptors) {\n    if (interceptor.afterQueryExecution) {\n      await interceptor.afterQueryExecution(executionContext, actualQuery, result);\n    }\n  }\n\n  // Stream does not have `rows` in the result object and all rows are already transformed.\n  if (result.rows) {\n    for (const interceptor of clientConfiguration.interceptors) {\n      if (interceptor.transformRow) {\n        const transformRow = interceptor.transformRow;\n        const fields = result.fields;\n\n        // eslint-disable-next-line no-loop-func\n        const rows: $ReadOnlyArray<QueryResultRowType> = map(result.rows, (row) => {\n          return transformRow(executionContext, actualQuery, row, fields);\n        });\n\n        result = {\n          ...result,\n          rows,\n        };\n      }\n    }\n  }\n\n  for (const interceptor of clientConfiguration.interceptors) {\n    if (interceptor.beforeQueryResult) {\n      await interceptor.beforeQueryResult(executionContext, actualQuery, result);\n    }\n  }\n\n  return result;\n};\n"],"file":"executeQuery.js"}
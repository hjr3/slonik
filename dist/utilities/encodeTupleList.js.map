{"version":3,"sources":["../../src/utilities/encodeTupleList.js"],"names":["tupleList","columnTypes","Promise","resolve","reject","concatStream","payloadBuffer","encode","tupleStream","Readable","objectMode","pipe","on","error","lastTupleSize","tuple","length","Error","payload","Array","tupleColumnIndex","type","value","push"],"mappings":";;;;;;;AAEA;;AAGA;;AACA;;;;yBAUEA,S,EACAC,W,KACoB;AACpB,SAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtC,UAAMC,YAAY,GAAG,2BAAoBC,aAAD,IAAmB;AACzDH,MAAAA,OAAO,CAACG,aAAD,CAAP;AACD,KAFoB,CAArB;AAIA,UAAMC,MAAM,GAAG,oCAAf;AAEA,UAAMC,WAAW,GAAG,IAAIC,gBAAJ,CAAa;AAC/BC,MAAAA,UAAU,EAAE;AADmB,KAAb,CAApB;AAIAF,IAAAA,WAAW,CACRG,IADH,CACQJ,MADR,EAEGI,IAFH,CAEQN,YAFR,EAGGO,EAHH,CAGM,OAHN,EAGgBC,KAAD,IAAW;AACtBT,MAAAA,MAAM,CAACS,KAAD,CAAN;AACD,KALH;AAOA,QAAIC,aAAJ;;AAEA,SAAK,MAAMC,KAAX,IAAoBf,SAApB,EAA+B;AAC7B,UAAI,OAAOc,aAAP,KAAyB,QAAzB,IAAqCA,aAAa,KAAKC,KAAK,CAACC,MAAjE,EAAyE;AACvE,cAAM,IAAIC,KAAJ,CAAU,sEAAV,CAAN;AACD;;AAED,UAAIF,KAAK,CAACC,MAAN,KAAiBf,WAAW,CAACe,MAAjC,EAAyC;AACvC,cAAM,IAAIC,KAAJ,CAAU,qDAAV,CAAN;AACD;;AAEDH,MAAAA,aAAa,GAAGC,KAAK,CAACC,MAAtB;AAEA,YAAME,OAAO,GAAG,IAAIC,KAAJ,CAAUL,aAAV,CAAhB;AAEA,UAAIM,gBAAgB,GAAG,CAAC,CAAxB;;AAEA,aAAOA,gBAAgB,KAAKN,aAAa,GAAG,CAA5C,EAA+C;AAC7CI,QAAAA,OAAO,CAACE,gBAAD,CAAP,GAA4B;AAC1BC,UAAAA,IAAI,EAAEpB,WAAW,CAACmB,gBAAD,CADS;AAE1BE,UAAAA,KAAK,EAAEP,KAAK,CAACK,gBAAD;AAFc,SAA5B;AAID,OApB4B,CAsB7B;;;AACAZ,MAAAA,WAAW,CAACe,IAAZ,CAAiBL,OAAjB;AACD;;AAEDV,IAAAA,WAAW,CAACe,IAAZ,CAAiB,IAAjB;AACD,GA/CM,CAAP;AAgDD,C","sourcesContent":["// @flow\n\nimport {\n  Readable,\n} from 'stream';\nimport createConcatStream from 'concat-stream';\nimport {\n  deparser as createEncoder,\n} from 'pg-copy-streams-binary';\nimport type {\n  TypeNameIdentifierType,\n} from '../types';\n\nexport default (\n\n  // eslint-disable-next-line flowtype/no-weak-types\n  tupleList: $ReadOnlyArray<$ReadOnlyArray<any>>,\n  columnTypes: $ReadOnlyArray<TypeNameIdentifierType>,\n): Promise<Buffer> => {\n  return new Promise((resolve, reject) => {\n    const concatStream = createConcatStream((payloadBuffer) => {\n      resolve(payloadBuffer);\n    });\n\n    const encode = createEncoder();\n\n    const tupleStream = new Readable({\n      objectMode: true,\n    });\n\n    tupleStream\n      .pipe(encode)\n      .pipe(concatStream)\n      .on('error', (error) => {\n        reject(error);\n      });\n\n    let lastTupleSize;\n\n    for (const tuple of tupleList) {\n      if (typeof lastTupleSize === 'number' && lastTupleSize !== tuple.length) {\n        throw new Error('Each tuple in a list of tuples must have an equal number of members.');\n      }\n\n      if (tuple.length !== columnTypes.length) {\n        throw new Error('Column types length must match tuple member length.');\n      }\n\n      lastTupleSize = tuple.length;\n\n      const payload = new Array(lastTupleSize);\n\n      let tupleColumnIndex = -1;\n\n      while (tupleColumnIndex++ < lastTupleSize - 1) {\n        payload[tupleColumnIndex] = {\n          type: columnTypes[tupleColumnIndex],\n          value: tuple[tupleColumnIndex],\n        };\n      }\n\n      // $FlowFixMe\n      tupleStream.push(payload);\n    }\n\n    tupleStream.push(null);\n  });\n};\n"],"file":"encodeTupleList.js"}
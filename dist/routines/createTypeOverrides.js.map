{"version":3,"sources":["../../src/routines/createTypeOverrides.js"],"names":["connection","typeParsers","typeOverrides","TypeOverrides","length","typeNames","map","typeParser","name","postgresTypes","query","rows","postgresType","find","maybeTargetPostgresType","typname","Error","setTypeParser","oid","value","parse","typarray","arrayParser","create"],"mappings":";;;;;;;AAEA;;AAGA;;;;mCAMsBA,U,EAA4CC,W,KAA+D;AAC/H,QAAMC,aAAa,GAAG,IAAIC,sBAAJ,EAAtB;;AAEA,MAAIF,WAAW,CAACG,MAAZ,KAAuB,CAA3B,EAA8B;AAC5B,WAAOF,aAAP;AACD;;AAED,QAAMG,SAAS,GAAGJ,WAAW,CAACK,GAAZ,CAAiBC,UAAD,IAAgB;AAChD,WAAOA,UAAU,CAACC,IAAlB;AACD,GAFiB,CAAlB;AAIA,QAAMC,aAAa,GAAG,CACpB,MAAMT,UAAU,CAACU,KAAX,CAAiB,4EAAjB,EAA+F,CACnGL,SADmG,CAA/F,CADc,EAIpBM,IAJF;;AAMA,OAAK,MAAMJ,UAAX,IAAyBN,WAAzB,EAAsC;AACpC,UAAMW,YAAY,GAAGH,aAAa,CAACI,IAAd,CAAoBC,uBAAD,IAA6B;AACnE,aAAOA,uBAAuB,CAACC,OAAxB,KAAoCR,UAAU,CAACC,IAAtD;AACD,KAFoB,CAArB;;AAIA,QAAI,CAACI,YAAL,EAAmB;AACjB,YAAM,IAAII,KAAJ,CAAU,oBAAoBT,UAAU,CAACC,IAA/B,GAAsC,cAAhD,CAAN;AACD;;AAEDN,IAAAA,aAAa,CAACe,aAAd,CAA4BL,YAAY,CAACM,GAAzC,EAA+CC,KAAD,IAAW;AACvD,aAAOZ,UAAU,CAACa,KAAX,CAAiBD,KAAjB,CAAP;AACD,KAFD;;AAIA,QAAIP,YAAY,CAACS,QAAjB,EAA2B;AACzBnB,MAAAA,aAAa,CAACe,aAAd,CAA4BL,YAAY,CAACS,QAAzC,EAAoDF,KAAD,IAAW;AAC5D,eAAOG,qBACJC,MADI,CAEHJ,KAFG,EAGHZ,UAAU,CAACa,KAHR,EAKJA,KALI,EAAP;AAMD,OAPD;AAQD;AACF;;AAED,SAAOlB,aAAP;AACD,C","sourcesContent":["// @flow\n\nimport {\n  arrayParser,\n} from 'pg-types';\nimport TypeOverrides from 'pg/lib/type-overrides';\nimport type {\n  InternalDatabaseConnectionType,\n  TypeParserType,\n} from '../types';\n\nexport default async (connection: InternalDatabaseConnectionType, typeParsers: $ReadOnlyArray<TypeParserType>): TypeOverrides => {\n  const typeOverrides = new TypeOverrides();\n\n  if (typeParsers.length === 0) {\n    return typeOverrides;\n  }\n\n  const typeNames = typeParsers.map((typeParser) => {\n    return typeParser.name;\n  });\n\n  const postgresTypes = (\n    await connection.query('SELECT oid, typarray, typname FROM pg_type WHERE typname = ANY($1::text[])', [\n      typeNames,\n    ])\n  ).rows;\n\n  for (const typeParser of typeParsers) {\n    const postgresType = postgresTypes.find((maybeTargetPostgresType) => {\n      return maybeTargetPostgresType.typname === typeParser.name;\n    });\n\n    if (!postgresType) {\n      throw new Error('Database type \"' + typeParser.name + '\" not found.');\n    }\n\n    typeOverrides.setTypeParser(postgresType.oid, (value) => {\n      return typeParser.parse(value);\n    });\n\n    if (postgresType.typarray) {\n      typeOverrides.setTypeParser(postgresType.typarray, (value) => {\n        return arrayParser\n          .create(\n            value,\n            typeParser.parse,\n          )\n          .parse();\n      });\n    }\n  }\n\n  return typeOverrides;\n};\n"],"file":"createTypeOverrides.js"}
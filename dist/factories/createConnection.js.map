{"version":3,"sources":["../../src/factories/createConnection.js"],"names":["terminatePoolConnection","pool","connection","error","slonik","terminated","mock","_remove","_pulseQueue","createConnection","parentLog","clientConfiguration","connectionType","connectionHandler","poolHandler","query","ended","UnexpectedStateError","interceptor","interceptors","beforePoolConnection","maybeNewPool","log","poolId","remainingConnectionRetryLimit","connectionRetryLimit","connect","info","ConnectionError","message","typeOverrides","typeParsers","_types","native","connectionId","connectionLog","child","connectionContext","boundConnection","afterPoolConnection","result","beforePoolConnectionRelease","release"],"mappings":"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","sourcesContent":["// @flow\n\nimport {\n  serializeError,\n} from 'serialize-error';\nimport type {\n  MaybePromiseType,\n  ClientConfigurationType,\n  ConnectionTypeType,\n  DatabasePoolType,\n  DatabasePoolConnectionType,\n  InternalDatabaseConnectionType,\n  InternalDatabasePoolType,\n  LoggerType,\n  TaggedTemplateLiteralInvocationType,\n} from '../types';\nimport {\n  createTypeOverrides,\n} from '../routines';\nimport {\n  bindPoolConnection,\n} from '../binders';\nimport {\n  ConnectionError,\n  UnexpectedStateError,\n} from '../errors';\n\ntype ConnectionHandlerType = (\n  connectionLog: LoggerType,\n  connection: InternalDatabaseConnectionType,\n  boundConnection: DatabasePoolConnectionType,\n  clientConfiguration: ClientConfigurationType\n) => MaybePromiseType<*>;\n\ntype PoolHandlerType = (pool: DatabasePoolType) => Promise<*>;\n\nconst terminatePoolConnection = (pool, connection, error) => {\n  if (!connection.connection.slonik.terminated) {\n    connection.connection.slonik.terminated = error;\n  }\n\n  if (pool.slonik.mock) {\n    return;\n  }\n\n  pool._remove(connection);\n  pool._pulseQueue();\n};\n\n// eslint-disable-next-line complexity\nconst createConnection = async (\n  parentLog: LoggerType,\n  pool: InternalDatabasePoolType,\n  clientConfiguration: ClientConfigurationType,\n  connectionType: ConnectionTypeType,\n  connectionHandler: ConnectionHandlerType,\n  poolHandler: PoolHandlerType,\n  query?: TaggedTemplateLiteralInvocationType | null = null,\n) => {\n  if (pool.slonik.ended) {\n    throw new UnexpectedStateError('Connection pool shutdown has been already initiated. Cannot create a new connection.');\n  }\n\n  for (const interceptor of clientConfiguration.interceptors) {\n    if (interceptor.beforePoolConnection) {\n      const maybeNewPool = await interceptor.beforePoolConnection({\n        log: parentLog,\n        poolId: pool.slonik.poolId,\n        query,\n      });\n\n      if (maybeNewPool) {\n        return poolHandler(maybeNewPool);\n      }\n    }\n  }\n\n  let connection: InternalDatabaseConnectionType;\n\n  let remainingConnectionRetryLimit = clientConfiguration.connectionRetryLimit;\n\n  while (true) {\n    remainingConnectionRetryLimit--;\n\n    try {\n      connection = await pool.connect();\n\n      break;\n    } catch (error) {\n      parentLog.error({\n        error: serializeError(error),\n        remainingConnectionRetryLimit,\n      }, 'cannot establish connection');\n\n      if (remainingConnectionRetryLimit > 1) {\n        parentLog.info('retrying connection');\n\n        continue;\n      } else {\n        throw new ConnectionError(error.message);\n      }\n    }\n  }\n\n  if (!connection) {\n    throw new UnexpectedStateError('Connection handle is not present.');\n  }\n\n  if (!pool.slonik.mock) {\n    if (!pool.typeOverrides) {\n      pool.typeOverrides = createTypeOverrides(connection, clientConfiguration.typeParsers);\n    }\n\n    // eslint-disable-next-line id-match\n    connection._types = await pool.typeOverrides;\n\n    if (connection.native) {\n      // eslint-disable-next-line id-match\n      connection.native._types = await pool.typeOverrides;\n    }\n  }\n\n  const connectionId = connection.connection.slonik.connectionId;\n\n  const connectionLog = parentLog.child({\n    connectionId,\n  });\n\n  const connectionContext = {\n    connectionId,\n    connectionType,\n    log: connectionLog,\n    poolId: pool.slonik.poolId,\n  };\n\n  const boundConnection = bindPoolConnection(connectionLog, connection, clientConfiguration);\n\n  try {\n    for (const interceptor of clientConfiguration.interceptors) {\n      if (interceptor.afterPoolConnection) {\n        await interceptor.afterPoolConnection(connectionContext, boundConnection);\n      }\n    }\n  } catch (error) {\n    terminatePoolConnection(pool, connection, error);\n\n    throw error;\n  }\n\n  let result;\n\n  try {\n    result = await connectionHandler(connectionLog, connection, boundConnection, clientConfiguration);\n  } catch (error) {\n    terminatePoolConnection(pool, connection, error);\n\n    throw error;\n  }\n\n  try {\n    for (const interceptor of clientConfiguration.interceptors) {\n      if (interceptor.beforePoolConnectionRelease) {\n        await interceptor.beforePoolConnectionRelease(connectionContext, boundConnection);\n      }\n    }\n  } catch (error) {\n    terminatePoolConnection(pool, connection, error);\n\n    throw error;\n  }\n\n  if (pool.slonik.mock === false && pool.slonik.ended === false && connectionType === 'IMPLICIT_QUERY') {\n    // @todo Abstract into an array of queries that could be configured using `clientConfiguration`.\n    await connection.query('DISCARD ALL');\n    await connection.release();\n  } else {\n    // Do not use `connection.release()` for explicit connections:\n    //\n    // It is possible that user might mishandle connection release,\n    // and same connection is going to end up being used by multiple\n    // invocations of `pool.connect`, e.g.\n    //\n    // ```\n    // pool.connect((connection1) => { setTimeout(() => { connection1; }, 1000) });\n    // pool.connect((connection2) => { setTimeout(() => { connection2; }, 1000) });\n    // ```\n    //\n    // In the above scenario, connection1 and connection2 are going to be the same connection.\n    //\n    // `pool._remove(connection)` ensures that we create a new connection for each `pool.connect()`.\n    //\n    // The downside of this approach is that we cannot leverage idle connection pooling.\n    terminatePoolConnection(pool, connection, new ConnectionError('Forced connection termination (explicit connection).'));\n  }\n\n  return result;\n};\n\nexport default createConnection;\n"],"file":"createConnection.js"}
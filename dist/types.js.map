{"version":3,"sources":["../src/types.js"],"names":[],"mappings":";;AAUA","sourcesContent":["// @flow\n\n/* eslint-disable no-use-before-define, import/exports-last, flowtype/require-types-at-top, flowtype/require-compound-type-alias */\n\nimport type {\n  Readable,\n} from 'stream';\nimport type {\n  LoggerType,\n} from 'roarr';\nimport {\n  SlonikError,\n} from './errors';\n\nexport type {\n  LoggerType,\n};\n\nexport type TypeNameIdentifierType =\n  'bool' |\n  'bytea' |\n  'float4' |\n  'float8' |\n  'int2' |\n  'int4' |\n  'json' |\n  'text' |\n  'timestamptz';\n\nexport type SerializableValueType = string | number | boolean | null | {+[key: string]: SerializableValueType, ...} | $ReadOnlyArray<SerializableValueType>;\n\nexport type QueryIdType = string;\n\nexport type MaybePromiseType<T> = T | Promise<T>;\n\nexport type StreamHandlerType = (stream: Readable) => void;\n\nexport type ConnectionTypeType = 'EXPLICIT' | 'IMPLICIT_QUERY' | 'IMPLICIT_TRANSACTION';\n\nexport type FieldType = {|\n  +dataTypeId: number,\n  +name: string,\n|};\n\ntype NoticeType = {|\n  +code: string,\n  +length: number,\n  +message: string,\n  +name: string,\n  +severity: string,\n  +where: string,\n|};\n\nexport type QueryResultType<T> = {|\n  +command: 'DELETE' | 'INSERT' | 'SELECT' | 'UPDATE',\n  +fields: $ReadOnlyArray<FieldType>,\n  +notices: $ReadOnlyArray<NoticeType>,\n  +rowCount: number,\n  +rows: $ReadOnlyArray<T>,\n|};\n\n// eslint-disable-next-line flowtype/no-weak-types\nexport type InternalDatabasePoolType = any;\n\n// eslint-disable-next-line flowtype/no-weak-types\nexport type InternalDatabaseConnectionType = any;\n\n/**\n * @property captureStackTrace Dictates whether to capture stack trace before executing query. Middlewares access stack trace through query execution context. (Default: true)\n * @property connectionRetryLimit Number of times to retry establishing a new connection. (Default: 3)\n * @property connectionTimeout Timeout (in milliseconds) after which an error is raised if connection cannot cannot be established. (Default: 5000)\n * @property idleInTransactionSessionTimeout Timeout (in milliseconds) after which idle clients are closed. Use 'DISABLE_TIMEOUT' constant to disable the timeout. (Default: 60000)\n * @property idleTimeout Timeout (in milliseconds) after which idle clients are closed. Use 'DISABLE_TIMEOUT' constant to disable the timeout. (Default: 5000)\n * @property interceptors An array of [Slonik interceptors](https://github.com/gajus/slonik#slonik-interceptors).\n * @property maximumPoolSize Do not allow more than this many connections. Use 'DISABLE_TIMEOUT' constant to disable the timeout. (Default: 10)\n * @property preferNativeBindings Uses libpq bindings when `pg-native` module is installed. (Default: true)\n * @property statementTimeout Timeout (in milliseconds) after which database is instructed to abort the query. Use 'DISABLE_TIMEOUT' constant to disable the timeout. (Default: 60000)\n * @property transactionRetryLimit Number of times a transaction failing with Transaction Rollback class error is retried. (Default: 5)\n * @property typeParsers An array of [Slonik type parsers](https://github.com/gajus/slonik#slonik-type-parsers).\n */\nexport type ClientConfigurationInputType = {|\n  +captureStackTrace?: boolean,\n  +connectionRetryLimit?: number,\n  +connectionTimeout?: number | 'DISABLE_TIMEOUT',\n  +idleInTransactionSessionTimeout?: number | 'DISABLE_TIMEOUT',\n  +idleTimeout?: number | 'DISABLE_TIMEOUT',\n  +interceptors?: $ReadOnlyArray<InterceptorType>,\n  +maximumPoolSize?: number,\n  +preferNativeBindings?: boolean,\n  +statementTimeout?: number | 'DISABLE_TIMEOUT',\n  +transactionRetryLimit?: number,\n  +typeParsers?: $ReadOnlyArray<TypeParserType>,\n|};\n\nexport type ClientConfigurationType = {|\n  +captureStackTrace: boolean,\n  +connectionRetryLimit: number,\n  +connectionTimeout: number | 'DISABLE_TIMEOUT',\n  +idleInTransactionSessionTimeout: number | 'DISABLE_TIMEOUT',\n  +idleTimeout: number | 'DISABLE_TIMEOUT',\n  +interceptors: $ReadOnlyArray<InterceptorType>,\n  +maximumPoolSize: number,\n  +preferNativeBindings: boolean,\n  +statementTimeout: number | 'DISABLE_TIMEOUT',\n  +transactionRetryLimit: number,\n  +typeParsers: $ReadOnlyArray<TypeParserType>,\n|};\n\nexport type StreamFunctionType = (\n  sql: TaggedTemplateLiteralInvocationType,\n  streamHandler: StreamHandlerType\n\n// $FlowFixMe\n) => Promise<null>;\n\nexport type QueryCopyFromBinaryFunctionType = (\n  streamQuery: TaggedTemplateLiteralInvocationType,\n\n  // eslint-disable-next-line flowtype/no-weak-types\n  tupleList: $ReadOnlyArray<$ReadOnlyArray<any>>,\n  columnTypes: $ReadOnlyArray<TypeNameIdentifierType>\n\n// $FlowFixMe\n) => Promise<null>;\n\ntype CommonQueryMethodsType = {|\n  +any: QueryAnyFunctionType,\n  +anyFirst: QueryAnyFirstFunctionType,\n  +many: QueryManyFunctionType,\n  +manyFirst: QueryManyFirstFunctionType,\n  +maybeOne: QueryMaybeOneFunctionType,\n  +maybeOneFirst: QueryMaybeOneFirstFunctionType,\n  +one: QueryOneFunctionType,\n  +oneFirst: QueryOneFirstFunctionType,\n  +query: QueryFunctionType,\n|};\n\nexport type DatabaseTransactionConnectionType = {|\n  ...$Exact<CommonQueryMethodsType>,\n  +transaction: (handler: TransactionFunctionType) => Promise<*>,\n|};\n\nexport type TransactionFunctionType = (connection: DatabaseTransactionConnectionType) => Promise<*>;\n\nexport type DatabasePoolConnectionType = {|\n  ...$Exact<CommonQueryMethodsType>,\n  +copyFromBinary: QueryCopyFromBinaryFunctionType,\n  +stream: StreamFunctionType,\n  +transaction: (handler: TransactionFunctionType) => Promise<*>,\n|};\n\nexport type ConnectionRoutineType = (connection: DatabasePoolConnectionType) => Promise<*>;\n\nexport type PoolStateType = {|\n  +activeConnectionCount: number,\n  +ended: boolean,\n  +idleConnectionCount: number,\n  +waitingClientCount: number,\n|};\n\nexport type DatabasePoolType = {|\n  ...$Exact<CommonQueryMethodsType>,\n  +connect: (connectionRoutine: ConnectionRoutineType) => Promise<*>,\n  +copyFromBinary: QueryCopyFromBinaryFunctionType,\n  +end: () => Promise<void>,\n  +getPoolState: () => PoolStateType,\n  +stream: StreamFunctionType,\n  +transaction: (handler: TransactionFunctionType) => Promise<*>,\n|};\n\n/**\n * This appears to be the only sane way to have a generic database connection type\n * that can be refined, i.e. DatabaseConnectionType => DatabasePoolType.\n */\nexport type DatabaseConnectionType =\n  $Shape<{\n    ...$Exact<DatabasePoolConnectionType>,\n    ...$Exact<DatabasePoolType>,\n    ...\n  }>;\n\ntype QueryResultRowColumnType = string | number | null;\n\nexport type QueryResultRowType = {\n  +[key: string]: QueryResultRowColumnType,\n  ...\n};\n\nexport type QueryType = {|\n  +sql: string,\n  +values: $ReadOnlyArray<PrimitiveValueExpressionType>,\n|};\n\nexport type SqlFragmentType = {|\n  +sql: string,\n  +values: $ReadOnlyArray<PrimitiveValueExpressionType>,\n|};\n\n/**\n * @property name Value of \"pg_type\".\"typname\" (e.g. \"int8\", \"timestamp\", \"timestamptz\").\n */\nexport type TypeParserType = {|\n  +name: string,\n  +parse: (value: string) => *,\n|};\n\n/**\n * @property log Instance of Roarr logger with bound connection context parameters.\n * @property poolId Unique connection pool ID.\n * @property query The query that is initiating the connection.\n */\nexport type PoolContextType = {|\n  +log: LoggerType,\n  +poolId: string,\n  +query: TaggedTemplateLiteralInvocationType | null,\n|};\n\n/**\n * @property connectionId Unique connection ID.\n * @property log Instance of Roarr logger with bound connection context parameters.\n * @property poolId Unique connection pool ID.\n */\nexport type ConnectionContextType = {|\n  +connectionId: string,\n  +connectionType: ConnectionTypeType,\n  +log: LoggerType,\n  +poolId: string,\n|};\n\ntype CallSiteType = {|\n  +columnNumber: number,\n  +fileName: string | null,\n  +lineNumber: number,\n|};\n\n/**\n * @property connectionId Unique connection ID.\n * @property log Instance of Roarr logger with bound query context parameters.\n * @property originalQuery A copy of the query before `transformQuery` middleware.\n * @property poolId Unique connection pool ID.\n * @property queryId Unique query ID.\n * @property queryInputTime `process.hrtime.bigint()` for when query was received.\n * @property sandbox Object used by interceptors to assign interceptor-specific, query-specific context.\n * @property transactionId Unique transaction ID.\n */\nexport type QueryContextType = {|\n  +connectionId: string,\n  +log: LoggerType,\n  +originalQuery: QueryType,\n  +poolId: string,\n  +queryId: QueryIdType,\n  +queryInputTime: number,\n  // eslint-disable-next-line flowtype/no-weak-types\n  +sandbox: Object,\n  +stackTrace: $ReadOnlyArray<CallSiteType> | null,\n  +transactionId?: string,\n|};\n\nexport type ArraySqlTokenType = {|\n  +memberType: TypeNameIdentifierType | SqlTokenType,\n  +type: 'SLONIK_TOKEN_ARRAY',\n  +values: $ReadOnlyArray<ValueExpressionType>,\n|};\n\nexport type BinarySqlTokenType = {|\n  +data: Buffer,\n  +type: 'SLONIK_TOKEN_BINARY',\n|};\n\nexport type IdentifierSqlTokenType = {|\n  +names: $ReadOnlyArray<string>,\n  +type: 'SLONIK_TOKEN_IDENTIFIER',\n|};\n\nexport type ListSqlTokenType = {|\n  +glue: SqlTokenType,\n  +members: $ReadOnlyArray<SqlTokenType>,\n  +type: 'SLONIK_TOKEN_LIST',\n|};\n\nexport type JsonSqlTokenType = {|\n  +value: SerializableValueType,\n  +type: 'SLONIK_TOKEN_JSON',\n|};\n\nexport type SqlSqlTokenType = {|\n  +sql: string,\n  +type: 'SLONIK_TOKEN_SQL',\n  +values: $ReadOnlyArray<PrimitiveValueExpressionType>,\n|};\n\nexport type UnnestSqlTokenType = {|\n  +columnTypes: $ReadOnlyArray<string>,\n  +tuples: $ReadOnlyArray<$ReadOnlyArray<ValueExpressionType>>,\n  +type: 'SLONIK_TOKEN_UNNEST',\n|};\n\nexport type PrimitiveValueExpressionType = $ReadOnlyArray<PrimitiveValueExpressionType> | string | number | boolean | null;\n\nexport type SqlTokenType =\n  ArraySqlTokenType |\n  BinarySqlTokenType |\n  IdentifierSqlTokenType |\n  JsonSqlTokenType |\n  ListSqlTokenType |\n  SqlSqlTokenType |\n  UnnestSqlTokenType;\n\nexport type ValueExpressionType =\n  SqlTokenType |\n  PrimitiveValueExpressionType;\n\nexport type NamedAssignmentType = {\n  +[key: string]: ValueExpressionType,\n  ...\n};\n\nexport type TaggedTemplateLiteralInvocationType = {|\n  +sql: string,\n  +type: 'SLONIK_TOKEN_SQL',\n  +values: $ReadOnlyArray<PrimitiveValueExpressionType>,\n|};\n\n/**\n * see https://twitter.com/kuizinas/status/914139352908943360\n */\nexport type SqlTaggedTemplateType = {|\n  // eslint-disable-next-line no-undef\n  [[call]]: (\n    parts: $ReadOnlyArray<string>,\n    ...values: $ReadOnlyArray<ValueExpressionType>\n  ) => SqlSqlTokenType,\n  array: (\n    values: $ReadOnlyArray<PrimitiveValueExpressionType>,\n    memberType: TypeNameIdentifierType | SqlTokenType\n  ) => ArraySqlTokenType,\n  binary: (\n    data: Buffer\n  ) => BinarySqlTokenType,\n  identifier: (\n    names: $ReadOnlyArray<string>\n  ) => IdentifierSqlTokenType,\n  json: (\n    value: SerializableValueType\n  ) => JsonSqlTokenType,\n  join: (\n    members: $ReadOnlyArray<ValueExpressionType>,\n    glue: SqlTokenType,\n  ) => ListSqlTokenType,\n  unnest: (\n\n    // Value might be $ReadOnlyArray<$ReadOnlyArray<PrimitiveValueExpressionType>>,\n    // or it can be infinitely nested array, e.g.\n    // https://github.com/gajus/slonik/issues/44\n    // eslint-disable-next-line flowtype/no-weak-types\n    tuples: $ReadOnlyArray<$ReadOnlyArray<any>>,\n    columnTypes: $ReadOnlyArray<string>\n  ) => UnnestSqlTokenType,\n|};\n\nexport type InternalQueryMethodType<R> = (\n  log: LoggerType,\n  connection: InternalDatabaseConnectionType,\n  clientConfiguration: ClientConfigurationType,\n  sql: string,\n  values: $ReadOnlyArray<PrimitiveValueExpressionType>,\n  uid?: QueryIdType\n) => Promise<R>;\n\nexport type InternalQueryAnyFirstFunctionType = InternalQueryMethodType<$ReadOnlyArray<QueryResultRowColumnType>>;\nexport type InternalQueryAnyFunctionType = InternalQueryMethodType<$ReadOnlyArray<QueryResultRowType>>;\nexport type InternalQueryFunctionType<T: QueryResultRowType> = InternalQueryMethodType<QueryResultType<T>>;\nexport type InternalQueryManyFirstFunctionType = InternalQueryMethodType<$ReadOnlyArray<QueryResultRowColumnType>>;\nexport type InternalQueryManyFunctionType = InternalQueryMethodType<$ReadOnlyArray<QueryResultRowType>>;\nexport type InternalQueryMaybeOneFirstFunctionType = InternalQueryMethodType<QueryResultRowColumnType | null>;\nexport type InternalQueryMaybeOneFunctionType = InternalQueryMethodType<QueryResultRowType | null>;\nexport type InternalQueryOneFirstFunctionType = InternalQueryMethodType<QueryResultRowColumnType>;\nexport type InternalQueryOneFunctionType = InternalQueryMethodType<QueryResultRowType>;\n\nexport type InternalCopyFromBinaryFunctionType = (\n  log: LoggerType,\n  connection: InternalDatabaseConnectionType,\n  clientConfiguration: ClientConfigurationType,\n  sql: string,\n  boundValues: $ReadOnlyArray<PrimitiveValueExpressionType>,\n\n  // eslint-disable-next-line flowtype/no-weak-types\n  tupleList: $ReadOnlyArray<$ReadOnlyArray<any>>,\n  columnTypes: $ReadOnlyArray<TypeNameIdentifierType>\n\n// eslint-disable-next-line flowtype/no-weak-types\n) => Promise<Object>;\n\nexport type InternalStreamFunctionType = (\n  log: LoggerType,\n  connection: InternalDatabaseConnectionType,\n  clientConfiguration: ClientConfigurationType,\n  sql: string,\n  values: $ReadOnlyArray<PrimitiveValueExpressionType>,\n  streamHandler: StreamHandlerType,\n  uid?: QueryIdType\n\n// eslint-disable-next-line flowtype/no-weak-types\n) => Promise<Object>;\n\nexport type InternalTransactionFunctionType = (\n  log: LoggerType,\n  connection: InternalDatabaseConnectionType,\n  clientConfiguration: ClientConfigurationType,\n  handler: TransactionFunctionType\n) => Promise<*>;\n\nexport type InternalNestedTransactionFunctionType = (\n  log: LoggerType,\n  connection: InternalDatabaseConnectionType,\n  clientConfiguration: ClientConfigurationType,\n  handler: TransactionFunctionType,\n  transactionDepth: number\n) => Promise<*>;\n\ntype QueryMethodType<R> = (\n  sql: TaggedTemplateLiteralInvocationType\n) => Promise<R>;\n\n// @todo Figure out a reasonable column type that user can specific further.\n// Using `QueryResultRowType` and `QueryResultRowColumnType` is not an option\n// because all cases where user specifies expected type cause an error, e.g.\n// `let fooId: number = await oneFirst()` would produce an error since\n// QueryResultRowColumnType type allows `string | number | null`.\n// Therefore, we can only safely assume the shape of the result, e.g. collection vs object.\n\n// eslint-disable-next-line flowtype/no-weak-types\ntype ExternalQueryResultRowColumnType = any;\n\n// eslint-disable-next-line flowtype/no-weak-types\ntype ExternalQueryResultRowType = Object;\n\nexport type QueryAnyFirstFunctionType = QueryMethodType<$ReadOnlyArray<ExternalQueryResultRowColumnType>>;\nexport type QueryAnyFunctionType = QueryMethodType<$ReadOnlyArray<ExternalQueryResultRowType>>;\nexport type QueryFunctionType = QueryMethodType<ExternalQueryResultRowType>;\nexport type QueryManyFirstFunctionType = QueryMethodType<$ReadOnlyArray<ExternalQueryResultRowColumnType>>;\nexport type QueryManyFunctionType = QueryMethodType<$ReadOnlyArray<ExternalQueryResultRowType>>;\nexport type QueryMaybeOneFirstFunctionType = QueryMethodType<ExternalQueryResultRowColumnType>;\nexport type QueryMaybeOneFunctionType = QueryMethodType<ExternalQueryResultRowType | null>;\nexport type QueryOneFirstFunctionType = QueryMethodType<ExternalQueryResultRowColumnType>;\nexport type QueryOneFunctionType = QueryMethodType<ExternalQueryResultRowType>;\n\nexport type InterceptorType = {|\n  +afterPoolConnection?: (\n    connectionContext: ConnectionContextType,\n    connection: DatabasePoolConnectionType\n  ) => MaybePromiseType<null>,\n  +afterQueryExecution?: (\n    queryContext: QueryContextType,\n    query: QueryType,\n    result: QueryResultType<QueryResultRowType>\n  ) => MaybePromiseType<null>,\n  +beforePoolConnection?: (\n    connectionContext: PoolContextType\n  ) => MaybePromiseType<?DatabasePoolType>,\n  +beforePoolConnectionRelease?: (\n    connectionContext: ConnectionContextType,\n    connection: DatabasePoolConnectionType\n  ) => MaybePromiseType<null>,\n  +beforeQueryExecution?: (\n    queryContext: QueryContextType,\n    query: QueryType\n  ) => MaybePromiseType<QueryResultType<QueryResultRowType> | null>,\n  +beforeQueryResult?: (\n    queryContext: QueryContextType,\n    query: QueryType,\n    result: QueryResultType<QueryResultRowType>\n  ) => MaybePromiseType<null>,\n  +beforeTransformQuery?: (\n    queryContext: QueryContextType,\n    query: QueryType\n  ) => MaybePromiseType<null>,\n  +queryExecutionError?: (\n    queryContext: QueryContextType,\n    query: QueryType,\n    error: SlonikError\n  ) => MaybePromiseType<null>,\n  +transformQuery?: (\n    queryContext: QueryContextType,\n    query: QueryType\n  ) => QueryType,\n  +transformRow?: (\n    queryContext: QueryContextType,\n    query: QueryType,\n    row: QueryResultRowType,\n    fields: $ReadOnlyArray<FieldType>\n  ) => QueryResultRowType,\n|};\n\nexport type IdentifierNormalizerType = (identifierName: string) => string;\n"],"file":"types.js"}